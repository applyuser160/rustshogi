from abc import ABC, abstractmethod
from enum import Enum

class Address:
    column: int
    row: int

    def __init__(self, column: int, row: int) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def to_int(self) -> int: ...

class ColorType(Enum):
    Black = 0
    White = 1
    ColorNumber = 2

    def __init__(self, value: int) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class PieceType(Enum):
    King = 1
    Gold = 2
    Rook = 3
    Bishop = 4
    Silver = 5
    Knight = 6
    Lance = 7
    Pawn = 8
    Dragon = 9
    Horse = 10
    ProSilver = 11
    ProKnight = 12
    ProLance = 13
    ProPawn = 14

    def __init__(self, value: int) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class Piece:
    owner: ColorType
    piece_type: PieceType

    def __init__(self, owner: ColorType, piece_type: PieceType) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...

class Move:
    def __init__(
        self,
        csa: str | None = None,
        from_address: Address | None = None,
        to_address: Address | None = None,
        promote: bool = False,
        piece: Piece | None = None,
    ) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def is_drop(self) -> bool: ...
    def is_promote(self) -> bool: ...
    def get_from(self) -> Address: ...
    def get_to(self) -> Address: ...
    def get_piece(self) -> Piece: ...

class Hand:
    pieces: list[Piece]
    counts: list[int]

    def __init__(self, pieces: list[Piece], counts: list[int]) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def add_piece(self, color_type: ColorType, piece_type: PieceType) -> None: ...
    def add_pieces(
        self, color_type: ColorType, piece_type: PieceType, count: int
    ) -> None: ...
    def decrease_piece(self, color_type: ColorType, piece_type: PieceType) -> None: ...
    def get_player_pieces(self, color_type: ColorType) -> list[Piece]: ...

class Board:
    def __init__(self, sfen: str = "startpos") -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, value: object) -> bool: ...
    def __ne__(self, value: object) -> bool: ...
    def deploy(
        self, address: Address, piece_type: PieceType, color: ColorType
    ) -> None: ...
    def startpos(self) -> None: ...
    def get_piece(self, address: Address) -> Piece: ...
    def search_moves(self, color: ColorType) -> list[Move]: ...
    def execute_move(self, moves: Move) -> None: ...
    def is_finished(self) -> tuple[bool, ColorType]: ...
    def to_vector(self, target_dimensions: int | None = None) -> list[float]: ...

class Game:
    def __init__(
        self,
        board: Board = Board("startpos"),
        move_number: int = 1,
        turn: ColorType = ColorType.Black,
        winner: ColorType = ColorType.Black,
    ) -> None: ...
    def input_board(self, sfen: str) -> None: ...
    def input_hand(self, sfen: str) -> None: ...
    def input_move_number(self, sfen: str) -> None: ...
    def input_turn(self, sfen: str) -> None: ...
    def is_finished(self) -> tuple[bool, ColorType]: ...
    def execute_move(self, moves: Move) -> None: ...
    def random_play(self) -> Game: ...
    def random_move(self, num: int, threads: int | None = None) -> list[MctsResult]: ...
    def generate_random_board(self) -> Board: ...

class MctsResult:
    board: Board
    mv: Move
    white_wins: int
    black_wins: int
    total_games: int

    def merge(self, other: MctsResult) -> None: ...

class Evaluator(ABC):
    @abstractmethod
    def evaluate(self, board: Board, color: ColorType) -> float: ...

class NeuralEvaluator(Evaluator):
    def __init__(
        self,
        db_type_str: str | None = None,
        connection_string: str | None = None,
        model_path: str | None = None,
    ) -> None: ...
    def init_database(self) -> None: ...
    def generate_and_save_random_boards(self, count: int) -> int: ...
    def update_records_with_random_games(
        self,
        trials_per_record: int,
        max_records: int | None,
        num_threads: int,
    ) -> int: ...
    def train_model(
        self,
        min_games: int,
        learning_rate: float,
        batch_size: int,
        num_epochs: int,
        model_save_path: str,
    ) -> None: ...
    def evaluate_position(
        self, board: Board, model_path: str | None = None
    ) -> tuple[float, float, float]: ...
    def get_database_stats(self) -> tuple[int, int, int]: ...
    def evaluate(self, board: Board, color: ColorType) -> float: ...

class SimpleEvaluator(Evaluator):
    def __init__(self) -> None: ...
    def evaluate(self, board: Board, color: ColorType) -> float: ...

class EvaluationResult:
    score: float
    best_move: Move | None
    nodes_searched: int

class SearchStrategy(ABC):
    pass

class MinMaxSearchStrategy:
    def __init__(self, max_nodes: int) -> None: ...

class AlphaBetaSearchStrategy:
    def __init__(self, max_nodes: int) -> None: ...

class SearchEngine:
    def __init__(
        self,
        algorithm: str = "minmax",
        max_nodes: int = 1000000,
        evaluator: Evaluator | None = None,
    ) -> None: ...
    def search(
        self, board: Board, color: ColorType, depth: int, limit: int | None = None
    ) -> list[EvaluationResult]: ...
