# ??????????

???????????rustshogi????????????????????10?????????

## 1. board.rs: startpos()?????????

**???:**
- `startpos()`???200???????`deploy()`???????????
- ??????????????????????

**??:**
????????????????????????

```rust
// ??????????
struct InitialPiece {
    col: u8,
    row: u8,
    piece_type: PieceType,
    color: ColorType,
}

const INITIAL_POSITIONS: &[InitialPiece] = &[
    InitialPiece { col: 1, row: 1, piece_type: PieceType::Lance, color: ColorType::Black },
    InitialPiece { col: 2, row: 1, piece_type: PieceType::Knight, color: ColorType::Black },
    // ... ???
];

pub fn startpos(&mut self) {
    for pos in INITIAL_POSITIONS {
        self.deploy(
            Address::from_numbers(pos.col, pos.row).to_index(),
            pos.piece_type,
            pos.color,
        );
    }
    self.hand = Hand::new();
}
```

**??:** ????????????????????

---

## 2. board.rs: search_moves()?search_moves_no_cache()???

**???:**
- `search_moves()`?`search_moves_no_cache()`????????????????50??
- ?????????????

**??:**
????????????????????????????

```rust
fn search_moves_internal(&self, color: ColorType, use_cache: bool) -> Vec<Move> {
    if use_cache {
        let mut cache = MOVE_CACHE.lock().unwrap();
        if let Some(moves) = cache.get(&(self.clone(), color)) {
            return moves.clone();
        }
    }

    // ??????????
    let mut vector_move: Vec<Move> = Vec::with_capacity(128);
    // ... ????? ...

    if use_cache {
        let mut cache = MOVE_CACHE.lock().unwrap();
        cache.put((self.clone(), color), vector_move.clone());
    }

    vector_move
}

pub fn search_moves(&self, color: ColorType) -> Vec<Move> {
    self.search_moves_internal(color, true)
}

pub fn search_moves_no_cache(&self, color: ColorType) -> Vec<Move> {
    self.search_moves_internal(color, false)
}
```

**??:** ?????????????

---

## 3. board.rs: to_string()??????????

**???:**
- `to_string()`????????????????????????????40??

**??:**
?????????????????

```rust
fn format_hand_string(&self, color: ColorType) -> String {
    let mut hand_str = String::new();
    for piece_type in [
        PieceType::King, PieceType::Gold, PieceType::Rook,
        PieceType::Bichop, PieceType::Silver, PieceType::Knight,
        PieceType::Lance, PieceType::Pawn,
    ].iter() {
        let count = self.hand.get_count(color, *piece_type);
        if count > 0 {
            if count > 1 {
                hand_str.push_str(&count.to_string());
            }
            let piece_char = Piece::from(color, *piece_type).to_string();
            hand_str.push_str(&piece_char);
        }
    }
    hand_str
}

pub fn to_string(&self) -> String {
    // ???????...
    
    // ?????
    result.push(' ');
    let hand_str = self.format_hand_string(ColorType::Black)
        + &self.format_hand_string(ColorType::White);
    
    if hand_str.is_empty() {
        result.push('-');
    } else {
        result.push_str(&hand_str);
    }
    result
}
```

**??:** ?????????????

---

## 4. game.rs: ?????????????????

**???:**
- 5???????`random_move_parallel`, `random_move_sequential`, `random_move_parallel_chunked`, `random_move_parallel_thread_local`, `random_move_parallel_batched`?????????????????????
- ???????????????????????????????

**??:**
?????????????????????

```rust
fn execute_random_playout(
    &self,
    initial_board: &Board,
    initial_turn: ColorType,
    use_cache: bool,
) -> ColorType {
    let mut game = Game::from(initial_board.clone(), 1, initial_turn, ColorType::None);
    
    while !game.is_finished().0 {
        let moves = if use_cache {
            game.board.search_moves(game.turn)
        } else {
            game.board.search_moves_no_cache(game.turn)
        };
        
        if moves.is_empty() {
            break;
        }
        
        let move_count = moves.len();
        let mut random = Random::new(0, (move_count - 1) as u16);
        let random_move = &moves[random.generate_one() as usize];
        game.execute_move(random_move);
    }
    
    let (_is_finished, winner) = game.is_finished();
    winner
}

// ???????????????
pub fn random_move_parallel(&self, num: usize, num_threads: usize) -> Vec<MctsResult> {
    // ... ????????? ...
    // execute_random_playout()?????
}
```

**??:** ???????????????????

---

## 5. evaluator/neural.rs: ????????????

**???:**
- SQLite?PostgreSQL????????????????
- `init_database()`, `generate_and_save_random_boards()`, `update_records_with_random_games()`, `fetch_batch_from_db()`, `get_database_stats()`??????????????????

**??:**
??????????????????

```rust
trait DatabaseOperations {
    fn init_table(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
    fn insert_board(&self, board_sfen: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
    fn fetch_records(&self, query: &str) -> Result<Vec<(i64, String)>, Box<dyn std::error::Error + Send + Sync>>;
    fn update_record(&self, id: i64, white_wins: i32, black_wins: i32, total_games: i32) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
    // ... ????
}

struct SqliteDatabase {
    path: String,
}

struct PostgresDatabase {
    connection_string: String,
}

impl DatabaseOperations for SqliteDatabase {
    // SQLite??
}

impl DatabaseOperations for PostgresDatabase {
    // PostgreSQL??
}
```

**??:** ????????????DB?????

---

## 6. evaluator/neural.rs: train_model()?????

**???:**
- `train_model()`??300???????
- ????????????????????????????

**??:**
??????????

```rust
impl NeuralEvaluator {
    fn fetch_and_prepare_batch(&self, db_offset: usize, batch_size: usize) -> Result<Vec<(Vec<f32>, Vec<f32>)>, Box<dyn std::error::Error + Send + Sync>> {
        // ???????????????????
    }

    fn train_single_batch(
        &self,
        model: &mut NnModel<Autodiff<NdArray>>,
        optim: &mut Optimizer,
        batch: &[(Vec<f32>, Vec<f32>)],
        current_lr: f64,
    ) -> f32 {
        // ??????????
    }

    fn print_progress(&self, processed: usize, total: usize, start_time: Instant) {
        // ????
    }

    pub fn train_model(&self, ...) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // ????????????????????
        for epoch in 0..training_config.num_epochs {
            // fetch_and_prepare_batch()?train_single_batch()???
        }
    }
}
```

**??:** ??????????????????????????

---

## 7. search/: AlphaBeta?MinMax????????

**???:**
- `AlphaBetaSearchStrategy::search()`?`MinMaxSearchStrategy::search()`????????
- ???????????????????

**??:**
???????????????

```rust
pub mod common {
    use super::super::board::Board;
    use super::super::color::ColorType;
    use super::super::evaluator::abst::Evaluator;
    use super::super::moves::Move;
    use super::EvaluationResult;

    pub fn create_empty_result(evaluator: &dyn Evaluator, board: &Board, color: ColorType) -> EvaluationResult {
        EvaluationResult {
            score: evaluator.evaluate(board, color),
            best_move: None,
            nodes_searched: 1,
        }
    }

    pub fn find_best_move<F>(
        board: &Board,
        color: ColorType,
        moves: &[Move],
        score_fn: F,
    ) -> (Move, f32)
    where
        F: Fn(&Board, &Move) -> f32,
    {
        let mut best_score = f32::NEG_INFINITY;
        let mut best_move = moves[0].clone();
        
        for mv in moves {
            let mut new_board = board.clone();
            new_board.execute_move(mv);
            let score = score_fn(&new_board, mv);
            
            if score > best_score {
                best_score = score;
                best_move = mv.clone();
            }
        }
        
        (best_move, best_score)
    }
}

// AlphaBetaSearchStrategy?MinMaxSearchStrategy????????
```

**??:** ?????????????

---

## 8. evaluator/neural.rs: ????????????

**???:**
- ?????????????????????
- SQLite?PostgreSQL?????????????????????

**??:**
???????????????

```rust
struct DatabaseConnection {
    db_type: DatabaseType,
}

impl DatabaseConnection {
    fn with_connection<F, R>(
        &self,
        operation: F,
    ) -> Result<R, Box<dyn std::error::Error + Send + Sync>>
    where
        F: FnOnce(&dyn DatabaseOperations) -> Result<R, Box<dyn std::error::Error + Send + Sync>>,
    {
        match &self.db_type {
            DatabaseType::Sqlite(path) => {
                let conn = rusqlite::Connection::open(path)?;
                // ?????
            }
            DatabaseType::Postgres(conn_str) => {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async {
                    let (client, connection) = tokio_postgres::connect(conn_str, tokio_postgres::NoTls).await?;
                    // ?????
                })
            }
        }
    }
}
```

**??:** ??????????????????????

---

## 9. game.rs: ???????????

**???:**
- ????????????????????????????

**??:**
??????????????????

```rust
impl Game {
    fn select_random_move(&self, moves: &[Move]) -> Option<&Move> {
        if moves.is_empty() {
            return None;
        }
        let mut random = Random::new(0, (moves.len() - 1) as u16);
        Some(&moves[random.generate_one() as usize])
    }

    fn select_random_move_index(&self, move_count: usize) -> usize {
        let mut random = Random::new(0, (move_count - 1) as u16);
        random.generate_one() as usize
    }
}

// ????????
```

**??:** ??????????????

---

## 10. board.rs: execute_move()??????????????

**???:**
- `execute_move()`??????????????????15??

**??:**
?????????????????

```rust
impl Board {
    fn promote_piece_type(piece_type: PieceType) -> PieceType {
        match piece_type {
            PieceType::Rook => PieceType::Dragon,
            PieceType::Bichop => PieceType::Horse,
            PieceType::Silver => PieceType::ProSilver,
            PieceType::Knight => PieceType::ProKnight,
            PieceType::Lance => PieceType::ProLance,
            PieceType::Pawn => PieceType::ProPawn,
            _ => piece_type, // ?????????????
        }
    }

    pub fn execute_move(&mut self, moves: &Move) {
        // ... ????? ...
        
        if moves.get_is_promote() {
            let piece_type = self.get_piece_type_from_index(from_index);
            let color_type = self.get_color_type_from_index(from_index);
            self.drop(from_index);
            
            let promoted_piece_type = Self::promote_piece_type(piece_type);
            self.deploy(to_index, promoted_piece_type, color_type);
        } else {
            self.move_standard(from_index, to_index);
        }
    }
}
```

**??:** ???????????????

---

## ???

??10????????????????????????????????

- **???????**: ?500-800???????
- **?????**: ?????????????????????
- **?????**: ????????????????
- **??????**: ???????????????????????????

?????????????????????
